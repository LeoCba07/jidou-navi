-- Fix Upvote XP Exploit & Level Sync
-- 1. Deducts XP when an upvote is removed.
-- 2. Ensures Level is recalculated whenever XP changes (up or down).

-- ==========================================
-- 1. REMOVE UPVOTE (Fix Exploit + Sync Level)
-- ==========================================
CREATE OR REPLACE FUNCTION remove_upvote(p_machine_id UUID)
RETURNS JSON AS $$
DECLARE
    weekly_count INT;
    max_weekly_upvotes INT := 3;
    xp_per_upvote INT := 5;
BEGIN
    -- Check if user is authenticated
    IF auth.uid() IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'not_authenticated');
    END IF;

    -- Check if upvote exists
    IF NOT EXISTS (
        SELECT 1 FROM machine_upvotes
        WHERE user_id = auth.uid() AND machine_id = p_machine_id
    ) THEN
        RETURN json_build_object('success', false, 'error', 'not_upvoted');
    END IF;

    -- Remove upvote
    DELETE FROM machine_upvotes
    WHERE user_id = auth.uid() AND machine_id = p_machine_id;

    -- Deduct XP and Recalculate Level
    -- Level formula: floor(0.1 * sqrt(XP)) + 1
    UPDATE profiles
    SET 
        xp = GREATEST(0, COALESCE(xp, 0) - xp_per_upvote),
        level = floor(0.1 * sqrt(GREATEST(0, COALESCE(xp, 0) - xp_per_upvote))) + 1
    WHERE id = auth.uid();

    -- Get remaining weekly count
    SELECT COUNT(*)::INT INTO weekly_count
    FROM machine_upvotes
    WHERE user_id = auth.uid()
      AND created_at >= date_trunc('week', NOW());

    RETURN json_build_object(
        'success', true,
        'remaining_votes', max_weekly_upvotes - weekly_count
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ==========================================
-- 2. UPVOTE MACHINE (Sync Level Fix)
-- ==========================================
-- Redefining this to ensure level increases if XP threshold is crossed
CREATE OR REPLACE FUNCTION upvote_machine(p_machine_id UUID)
RETURNS JSON AS $$
DECLARE
    weekly_count INT;
    max_weekly_upvotes INT := 3;
    xp_per_upvote INT := 5;
BEGIN
    -- Check if user is authenticated
    IF auth.uid() IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'not_authenticated');
    END IF;

    -- Check if already upvoted this machine
    IF EXISTS (
        SELECT 1 FROM machine_upvotes
        WHERE user_id = auth.uid() AND machine_id = p_machine_id
    ) THEN
        RETURN json_build_object('success', false, 'error', 'already_upvoted');
    END IF;

    -- Check weekly limit
    SELECT COUNT(*)::INT INTO weekly_count
    FROM machine_upvotes
    WHERE user_id = auth.uid()
      AND created_at >= date_trunc('week', NOW());

    IF weekly_count >= max_weekly_upvotes THEN
        RETURN json_build_object('success', false, 'error', 'weekly_limit_reached');
    END IF;

    -- Create upvote
    INSERT INTO machine_upvotes (user_id, machine_id)
    VALUES (auth.uid(), p_machine_id);

    -- Award XP and Recalculate Level
    UPDATE profiles
    SET 
        xp = COALESCE(xp, 0) + xp_per_upvote,
        level = floor(0.1 * sqrt(COALESCE(xp, 0) + xp_per_upvote)) + 1
    WHERE id = auth.uid();

    RETURN json_build_object(
        'success', true,
        'xp_awarded', xp_per_upvote,
        'remaining_votes', max_weekly_upvotes - weekly_count - 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;